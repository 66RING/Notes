---
title: 宏内核, 微内核, 多内核
author: 66RING
date: 2022-05-21
tags: 
- os
- system
mathjax: true
---

# 宏内核架构

> linux

整个单分两层：内核与应用。

CPU负责提供权限模式，高权限就是内核模式。

所有内核功能实现在一起：文件系统, 内存管理, 设备驱动, 进程调度等。拥有最高权限

结构性缺陷：

- 安全性可靠性
	* 模块间没有很强的隔离，**单点错误**
	* 如频繁更新的驱动，他的bug就可能影响到其他模块
- 实时性支持不足
	* 系统太复杂，无法做出最坏分析
- 过于庞大阻碍创新
	* 2800行代码


# 微内核架构

内核变小，**功能放到用户态** 作为应用运行(称为Server)。使用IPC机制协作

**内核还剩什么?**

- Mach为例，参考人家是怎么抽象的
	* 任务和线程管理：对CPU抽象
	* 调度接口，用户自定义调度策略
	* 进程间通信IPC
	* 内存对象管理：内存资源抽象
	* 系统调用重定向： **用户态拦截和处理系统调用**
		+ 实现二进制翻译，跟踪，调试等
	* 设备支持(利用IPC实现)
	* 用户态多进程
		+ 类似用户态线程库，可以多个映射到一个内核线程
	* 分布式支持
		+ 任务和资源映射到集群不同节点


- QNX
	* Quick Unix
- Google Fuchsia
	* **Zircon微内核**
- MINIX

- 性能差了点，隔离性强
	* **IPC性能差**
- 生态和兼容性问题


# 混合内核架构

> 混合，tradeoff

需要性能的地方又放回内核，就不那么隔离了。(举个例子：既然说linux内核中大部分的bug都是来自驱动更新，那么驱动放在用户态咯。当然驱动也有需要性能的地方)


# 多内核Multikernel

传统OS是一个整体，依赖一个统一的全局内存。但是， **随着CPU核心数的增多，硬件提供缓存一致性成本增加** 。

**再考虑其他抽象的核** : GPU加速器，AI加速器，智能网卡等自己本身就有一个"CPU"

Multikernel的设计

- 每个core运行一个小内核
- OS整体是一个分布式系统
- 多个内核之上封装

e.g. Barrelfish操作系统


# 不断创新

架构还能不断创建，以下简易可以少走弯路：

1. 尽可能实现一些标准：如POSIX
2. 避免棘手的API：如fork
3. 避免不可扩展的POSIX API
4. 等

**设备间异构性和设备间通信异构性**



