---
title: acwing算法
author: 66RING
date: 2000-01-01
tags: 
- algorithm
mathjax: true
---

# Abstract


# Preface


# Algo

## 贪心

- 区间问题
	* 套路: 
		1. 左端点排序或右端点排序
	* 证明套路: ans <= cnt + ans >= cnt => cnt = ans得整算法正确性
- 区间分组问题
	* 套路: 
		1. 左端点排序或右端点排序
		2. 可以使用最小堆等数据结构, 用一个"代表者"代替整个组, 就不用维护整个map
	* 证明套路: ans <= cnt + ans >= cnt => cnt = ans得整算法正确性


## 搜索与图论

- 最短路径问题
	* 单源
		+ 不存在负权边
			+ 朴素dijkstra O(n**2)
			+ 堆优化dijkstra O(m*logn)
		+ 存在负权边
			+ bellman-ford O(mn)
			+ spfa 一般O(m), 最坏O(mn)
	* 多源
		+ floyd算法

### 图的邻接表表示

```c
// 添加a->b的链接表, 权值为c
// 这里用数组模拟, idx就相当于内存位置
// h[]是整个"结构体"的如何, 存放编号到内存地址(idx)的映射
void add(int a, int b, int c) {
  e[idx] = b; // 添加新节点
  w[idx] = c; // 添加节点权值
  ne[idx] = h[a]; // 头插链边
  h[a] = idx++;  // 更新头节点
}
```


### bellman-ford

可以处理有负权边的最短路问题

- algo: 单源负权边最短路问题, 多次遍历所有边即可。
	* TODO: 待证明
- 更新只用上一次的结果, 防止使用修改的后的进行计算
- 三角不等式
- 之所以可以解决负边问题是因为循环次数有限


### spfa算法

- 同样是解决存在负权边的最短路径问题。
- 是对bellman-ford的优化, bellman不假思索遍历所有, 但实际上如果dist没变那依赖它跳转的后续就不会改变
	* 所以只需要在dist缩小时才将它加入队列

举个例子, bellman-ford算法伪代码如下:

```c
for 所有点k(每个点都可能称为中介跳转):
	for 所有点i(枚举所有起点, 使用中介点k relax):
		relax(dist)
```

spfa伪代码如下

```c
exist[1] = true; 	// 是否存在队列中
for 所有有在队列q中的点k: 	// 使用一个队列保存dist缩小后的点
	exist[k] = false; 	// 清除记录, 后续必要时会重新添加
	for 所有k的邻接点i(枚举所有起点, 使用中介点k relax):
		if 更新:
			if !exist[j] q <- j; // 如果已经在组列中就不如
```


#### spfa判断负环

原理: 

1. n个点不存在环的话只有n-1条边, 所以如果`cnt[x] >= n`则说明存在环路。`cnt[x]`表示走到x所需的边数。`cnt[x] = cnt[prev(x)] + 1`, 一次走一步加一边。
2. 因为负环会让路径变小, 所以会被检测到


### Floyd

解决多源最短路径问题

使用三重循环, 最外层是中间点k的枚举。


### 朴素Prim

求最小生成树问题。关键在于怎么求点到**集合**的距离, 可以通过边的两个端点判断。

TODO: https://www.acwing.com/video/287/


## 动态规划(dp)

### 完全背包

- 完全背包问题, 物品个数不限
- `dp[i][j]`, 前i, 容量刚好j
    * `dp[i][j] = dp[i-1][j] + ... dp[i-1][j-n]`, 用0个j到用n个j的情况


### 最短子序列

- `dp[i][j]`str1前i和str2前j比较
    * `s[i] == s[j]`匹配时, 可以增加`dp[i-1][j-1]+1`
    * `s[i] != s[j]`不匹配时, 继承前人状态`max(dp[i-1][j], dp[i][j-1])`跳过i或j


### 最短编辑距离: 增删改的最小次数

- `dp[i][j]`, str1前i编辑成str2前j所需
- 初始
    * `dp[0][i]=i`不断插入, `dp[i][0]=i`不断删除
- 增: i处插入`dp[i-1][j]+1`
- 删: i处删除`dp[i][j-1]+1`
- 改: `dp[i-1][j-1]+1`
- 无: `s[i]==s[j]`继承`dp[i-1][j-1]`

上述操作取最小


### 石子合并

- 自底向上
    * 最终总是右量堆石子合并
    * 而用于合并的两堆石子也是由更小的两堆合并
    * 因此从len=2开始枚举合并情况, 然后选取min/max的结果
- "类哈夫曼问题", 结果是区间累加


### 最短hamilton路径

- 三角不等式
    * 枚举中转k, relax所有起点终点(i, j)
- 使用bitmap判断有效
- `dp[i][state]`当前再i, 节点使用情况`state`, 最短路径
    * 如果节点使用情况相同, 那必然要走相同的路线(因为最小)


### 蒙德里安的梦

- 逐步扩展
    * 先摆横再摆竖
    * `dp[i][state]`, 扩展到当前列i时, 状态为state时的有效摆放数
- 状态就是整个bitmap值域的枚举
- 预处理
    * 一个"互补表", 枚举state1, 可以有的合法情况state2
    * 排除奇数个连续的情况


## 数学

### 求约数

枚举一半, 算另一半。e.g. 枚举i那另一约数就是n/i, 注意`i == n/i`是只算一个


## 基础算法

### 二分

- `[left, mid]`, `[mid+1, right]`时, mid = (l+r)/2
- `[left, mid-1]`, `[mid, right]`时, mid = (l+r+1)/2
- 当然可以用自省的算法: `l + 1 == r`时特判


# misc

### 求质数

- 质除法
	* `i <= x/i`

```
bool is_prime(int x) {
	if (x < 2) return false; 
	for (int i = 2; i <= x/i; i++)
		if (x % i == 0)  {
			return false;
		}
	return true;
}
```

- 线性筛法


### 差分

- 一个数组a, ai表示i往后个数加`a[i]`
- 如果`a[i] = c`, `a[i+k+1] = -c`, 那么对数组a求前缀和就能实现对一段范围k, 加c的功能



